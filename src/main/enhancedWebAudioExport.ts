import fs from 'fs/promises';
import path from 'path';
import { PluginProject } from '@shared/types';
import { generateWebAudioPlugin } from './webAudioExport';

/**
 * Enhanced Web Audio Export with NPM Package Generation
 * Creates a complete, publishable NPM package
 */

export async function exportEnhancedWebAudioPackage(
  project: PluginProject,
  outputDir: string
): Promise<{ outputPath: string; packageName: string }> {
  const pluginName = project.name.replace(/\s+/g, '');
  const packageName = project.name.toLowerCase().replace(/\s+/g, '-');

  // Create package structure
  await fs.mkdir(outputDir, { recursive: true });
  await fs.mkdir(path.join(outputDir, 'src'), { recursive: true });
  await fs.mkdir(path.join(outputDir, 'dist'), { recursive: true });
  await fs.mkdir(path.join(outputDir, 'types'), { recursive: true });
  await fs.mkdir(path.join(outputDir, 'test'), { recursive: true });
  await fs.mkdir(path.join(outputDir, 'examples'), { recursive: true });
  await fs.mkdir(path.join(outputDir, 'docs'), { recursive: true });

  // Generate base plugin code
  const basePlugin = generateWebAudioPlugin(project);

  // Generate TypeScript source
  const tsSource = generateTypeScriptSource(project);
  await fs.writeFile(path.join(outputDir, 'src', 'index.ts'), tsSource, 'utf-8');

  // Generate TypeScript definitions
  const types = generateTypeScriptDefinitions(project);
  await fs.writeFile(path.join(outputDir, 'types', 'index.d.ts'), types, 'utf-8');

  // Generate enhanced package.json
  const packageJson = generateEnhancedPackageJSON(project);
  await fs.writeFile(path.join(outputDir, 'package.json'), packageJson, 'utf-8');

  // Generate build configuration
  const tsConfig = generateTSConfig();
  await fs.writeFile(path.join(outputDir, 'tsconfig.json'), tsConfig, 'utf-8');

  const rollupConfig = generateRollupConfig(project);
  await fs.writeFile(path.join(outputDir, 'rollup.config.js'), rollupConfig, 'utf-8');

  // Generate test suite
  const tests = generateTestSuite(project);
  await fs.writeFile(path.join(outputDir, 'test', 'plugin.test.js'), tests, 'utf-8');

  // Generate examples
  const basicExample = generateBasicExample(project);
  await fs.writeFile(path.join(outputDir, 'examples', 'basic.html'), basicExample, 'utf-8');

  const reactExample = generateReactExample(project);
  await fs.writeFile(path.join(outputDir, 'examples', 'react-example.jsx'), reactExample, 'utf-8');

  const vueExample = generateVueExample(project);
  await fs.writeFile(path.join(outputDir, 'examples', 'vue-example.vue'), vueExample, 'utf-8');

  // Generate documentation
  const readme = generateNPMReadme(project);
  await fs.writeFile(path.join(outputDir, 'README.md'), readme, 'utf-8');

  const apiDocs = generateAPIDocs(project);
  await fs.writeFile(path.join(outputDir, 'docs', 'API.md'), apiDocs, 'utf-8');

  // Generate additional files
  await generateAdditionalFiles(project, outputDir);

  return { outputPath: outputDir, packageName };
}

function generateTypeScriptSource(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `/**
 * ${project.name} - Web Audio Plugin
 * Generated by Sound Designer
 * @version ${project.version}
 * @license MIT
 */

export interface ${pluginName}Parameters {
${project.dspGraph.nodes
  .flatMap((node) =>
    (node.parameters || []).map((param) => {
      const paramName = sanitizeName(\`\${node.label || node.type}_\${param.name}\`);
      return \`  \${paramName}: number;\`;
    })
  )
  .join('\\n')}
}

export interface ${pluginName}Options {
  sampleRate?: number;
  bufferSize?: number;
  latency?: number;
}

export class ${pluginName}Plugin {
  private context: AudioContext;
  private input: GainNode;
  private output: GainNode;
  private parameters: Map<string, AudioParam | { value: number; min: number; max: number }>;
  private nodes: Map<string, AudioNode>;

  constructor(audioContext: AudioContext, options?: ${pluginName}Options) {
    this.context = audioContext;
    this.input = this.context.createGain();
    this.output = this.context.createGain();
    this.parameters = new Map();
    this.nodes = new Map();

    this.initialize(options);
  }

  private initialize(options?: ${pluginName}Options): void {
    // Initialize DSP nodes
    this.createNodes();

    // Setup routing
    this.buildDSPChain();

    // Apply options
    if (options) {
      this.applyOptions(options);
    }
  }

  private createNodes(): void {
${generateNodeCreation(project)}
  }

  private buildDSPChain(): void {
${generateDSPChainSetup(project)}
  }

  private applyOptions(options: ${pluginName}Options): void {
    // Apply configuration options
    if (options.latency !== undefined) {
      // Apply latency compensation
    }
  }

  /**
   * Connect plugin output to destination
   */
  public connect(destination: AudioNode | AudioParam): AudioNode | AudioParam {
    this.output.connect(destination as any);
    return destination;
  }

  /**
   * Disconnect plugin output
   */
  public disconnect(): void {
    this.output.disconnect();
  }

  /**
   * Get the input node for connecting audio sources
   */
  public getInput(): AudioNode {
    return this.input;
  }

  /**
   * Get the output node
   */
  public getOutput(): AudioNode {
    return this.output;
  }

  /**
   * Set parameter value with optional automation time
   */
  public setParameter(name: keyof ${pluginName}Parameters, value: number, time?: number): void {
    const param = this.parameters.get(name as string);
    if (!param) {
      console.warn(\`Parameter \${String(name)} not found\`);
      return;
    }

    if ('setValueAtTime' in param) {
      // AudioParam
      if (time === undefined || time === 0) {
        param.setValueAtTime(value, this.context.currentTime);
      } else {
        param.setValueAtTime(param.value, this.context.currentTime);
        param.linearRampToValueAtTime(value, this.context.currentTime + time);
      }
    } else {
      // Custom parameter
      param.value = value;
    }
  }

  /**
   * Get parameter value
   */
  public getParameter(name: keyof ${pluginName}Parameters): number | undefined {
    const param = this.parameters.get(name as string);
    return param ? param.value : undefined;
  }

  /**
   * Get all parameters as an object
   */
  public getState(): Partial<${pluginName}Parameters> {
    const state: any = {};
    this.parameters.forEach((param, name) => {
      state[name] = param.value;
    });
    return state;
  }

  /**
   * Set all parameters from state object
   */
  public setState(state: Partial<${pluginName}Parameters>): void {
    Object.entries(state).forEach(([name, value]) => {
      if (value !== undefined) {
        this.setParameter(name as keyof ${pluginName}Parameters, value);
      }
    });
  }

  /**
   * Export preset as JSON
   */
  public exportPreset(): string {
    return JSON.stringify(this.getState(), null, 2);
  }

  /**
   * Import preset from JSON
   */
  public importPreset(json: string): void {
    try {
      const state = JSON.parse(json);
      this.setState(state);
    } catch (error) {
      console.error('Failed to import preset:', error);
    }
  }

  /**
   * Clean up resources
   */
  public dispose(): void {
    this.disconnect();
    this.nodes.forEach((node) => {
      if ('stop' in node && typeof node.stop === 'function') {
        node.stop();
      }
      node.disconnect();
    });
    this.nodes.clear();
    this.parameters.clear();
  }
}

export default ${pluginName}Plugin;
`;
}

function generateTypeScriptDefinitions(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `// Type definitions for ${project.name}
// Project: ${project.name}
// Definitions by: Sound Designer

export interface ${pluginName}Parameters {
${project.dspGraph.nodes
  .flatMap((node) =>
    (node.parameters || []).map((param) => {
      const paramName = sanitizeName(\`\${node.label || node.type}_\${param.name}\`);
      const min = param.min ?? 0;
      const max = param.max ?? 1;
      return \`  /** Range: [\${min}, \${max}] */\\n  \${paramName}: number;\`;
    })
  )
  .join('\\n')}
}

export interface ${pluginName}Options {
  sampleRate?: number;
  bufferSize?: number;
  latency?: number;
}

export class ${pluginName}Plugin {
  constructor(audioContext: AudioContext, options?: ${pluginName}Options);

  connect(destination: AudioNode | AudioParam): AudioNode | AudioParam;
  disconnect(): void;
  getInput(): AudioNode;
  getOutput(): AudioNode;

  setParameter(name: keyof ${pluginName}Parameters, value: number, time?: number): void;
  getParameter(name: keyof ${pluginName}Parameters): number | undefined;

  getState(): Partial<${pluginName}Parameters>;
  setState(state: Partial<${pluginName}Parameters>): void;

  exportPreset(): string;
  importPreset(json: string): void;

  dispose(): void;
}

export default ${pluginName}Plugin;
`;
}

function generateEnhancedPackageJSON(project: PluginProject): string {
  const packageName = project.name.toLowerCase().replace(/\s+/g, '-');

  return JSON.stringify(
    {
      name: packageName,
      version: project.version,
      description: project.description,
      main: 'dist/index.cjs.js',
      module: 'dist/index.esm.js',
      browser: 'dist/index.umd.js',
      types: 'types/index.d.ts',
      files: ['dist', 'types', 'README.md', 'LICENSE'],
      scripts: {
        build: 'rollup -c',
        'build:watch': 'rollup -c -w',
        test: 'jest',
        'test:watch': 'jest --watch',
        lint: 'eslint src --ext .ts,.js',
        'type-check': 'tsc --noEmit',
        prepublishOnly: 'npm run build && npm test',
        docs: 'typedoc --out docs src/index.ts',
      },
      keywords: ['audio', 'plugin', 'web-audio', 'synthesizer', 'sound-designer', project.name.toLowerCase()],
      author: project.author || 'Sound Designer',
      license: 'MIT',
      repository: {
        type: 'git',
        url: 'https://github.com/yourusername/' + packageName,
      },
      bugs: {
        url: 'https://github.com/yourusername/' + packageName + '/issues',
      },
      homepage: 'https://github.com/yourusername/' + packageName + '#readme',
      devDependencies: {
        '@rollup/plugin-node-resolve': '^15.0.0',
        '@rollup/plugin-typescript': '^11.0.0',
        '@types/jest': '^29.0.0',
        '@types/node': '^20.0.0',
        '@typescript-eslint/eslint-plugin': '^6.0.0',
        '@typescript-eslint/parser': '^6.0.0',
        eslint: '^8.0.0',
        jest: '^29.0.0',
        rollup: '^3.0.0',
        'rollup-plugin-terser': '^7.0.0',
        'ts-jest': '^29.0.0',
        typedoc: '^0.25.0',
        typescript: '^5.0.0',
      },
      peerDependencies: {},
      engines: {
        node: '>=14.0.0',
      },
    },
    null,
    2
  );
}

function generateTSConfig(): string {
  return JSON.stringify(
    {
      compilerOptions: {
        target: 'ES2020',
        module: 'ESNext',
        lib: ['ES2020', 'DOM'],
        declaration: true,
        declarationDir: './types',
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: 'node',
        resolveJsonModule: true,
        isolatedModules: true,
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist', 'test', 'examples'],
    },
    null,
    2
  );
}

function generateRollupConfig(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `import typescript from '@rollup/plugin-typescript';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import { terser } from 'rollup-plugin-terser';

export default {
  input: 'src/index.ts',
  output: [
    {
      file: 'dist/index.cjs.js',
      format: 'cjs',
      sourcemap: true,
    },
    {
      file: 'dist/index.esm.js',
      format: 'esm',
      sourcemap: true,
    },
    {
      file: 'dist/index.umd.js',
      format: 'umd',
      name: '${pluginName}Plugin',
      sourcemap: true,
    },
    {
      file: 'dist/index.umd.min.js',
      format: 'umd',
      name: '${pluginName}Plugin',
      sourcemap: true,
      plugins: [terser()],
    },
  ],
  plugins: [
    nodeResolve(),
    typescript({
      tsconfig: './tsconfig.json',
    }),
  ],
};
`;
}

function generateTestSuite(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `/**
 * Test suite for ${project.name}
 */

describe('${pluginName}Plugin', () => {
  let audioContext;
  let plugin;

  beforeEach(() => {
    // Create a mock AudioContext
    audioContext = {
      createGain: jest.fn(() => ({
        connect: jest.fn(),
        disconnect: jest.fn(),
        gain: { value: 1 },
      })),
      createBiquadFilter: jest.fn(() => ({
        connect: jest.fn(),
        disconnect: jest.fn(),
        type: 'lowpass',
        frequency: { value: 1000, setValueAtTime: jest.fn(), linearRampToValueAtTime: jest.fn() },
        Q: { value: 1, setValueAtTime: jest.fn() },
      })),
      createOscillator: jest.fn(() => ({
        connect: jest.fn(),
        disconnect: jest.fn(),
        start: jest.fn(),
        stop: jest.fn(),
        type: 'sine',
        frequency: { value: 440 },
      })),
      currentTime: 0,
    };
  });

  test('should initialize plugin', () => {
    // Test initialization
    expect(() => {
      // plugin = new ${pluginName}Plugin(audioContext);
    }).not.toThrow();
  });

  test('should connect to destination', () => {
    // plugin = new ${pluginName}Plugin(audioContext);
    const destination = audioContext.createGain();
    // plugin.connect(destination);
    // expect(plugin.getOutput().connect).toHaveBeenCalledWith(destination);
  });

  test('should set and get parameters', () => {
    // plugin = new ${pluginName}Plugin(audioContext);
    // plugin.setParameter('someParam', 0.5);
    // expect(plugin.getParameter('someParam')).toBe(0.5);
  });

  test('should export and import presets', () => {
    // plugin = new ${pluginName}Plugin(audioContext);
    // const preset = plugin.exportPreset();
    // expect(typeof preset).toBe('string');
    // plugin.importPreset(preset);
  });

  test('should clean up on dispose', () => {
    // plugin = new ${pluginName}Plugin(audioContext);
    // plugin.dispose();
    // expect(plugin.getOutput().disconnect).toHaveBeenCalled();
  });
});
`;
}

function generateBasicExample(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');
  const packageName = project.name.toLowerCase().replace(/\s+/g, '-');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>${project.name} - Basic Example</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #1a1a1a; color: #fff; }
    .container { max-width: 800px; margin: 0 auto; }
    button { padding: 10px 20px; margin: 5px; cursor: pointer; }
    .controls { margin-top: 20px; }
    .control { margin: 10px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>${project.name}</h1>
    <p>Basic usage example</p>

    <div>
      <button id="start">Start Audio</button>
      <button id="stop">Stop Audio</button>
    </div>

    <div class="controls" id="controls"></div>
  </div>

  <script type="module">
    import ${pluginName}Plugin from '../dist/index.esm.js';

    let audioContext;
    let plugin;
    let oscillator;

    document.getElementById('start').addEventListener('click', async () => {
      if (!audioContext) {
        audioContext = new AudioContext();
        plugin = new ${pluginName}Plugin(audioContext);
        oscillator = audioContext.createOscillator();

        oscillator.connect(plugin.getInput());
        plugin.connect(audioContext.destination);
        oscillator.start();

        // Generate controls
        generateControls();
      }
      audioContext.resume();
    });

    document.getElementById('stop').addEventListener('click', () => {
      if (audioContext) {
        audioContext.suspend();
      }
    });

    function generateControls() {
      const container = document.getElementById('controls');
      const state = plugin.getState();

      Object.entries(state).forEach(([name, value]) => {
        const div = document.createElement('div');
        div.className = 'control';
        div.innerHTML = \`
          <label>\${name}: <span id="value-\${name}">\${value}</span></label>
          <input type="range" id="\${name}" min="0" max="1" step="0.01" value="\${value}">
        \`;

        const input = div.querySelector('input');
        const valueSpan = div.querySelector('span');

        input.addEventListener('input', (e) => {
          const val = parseFloat(e.target.value);
          plugin.setParameter(name, val);
          valueSpan.textContent = val.toFixed(2);
        });

        container.appendChild(div);
      });
    }
  </script>
</body>
</html>
`;
}

function generateReactExample(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `import React, { useEffect, useRef, useState } from 'react';
import ${pluginName}Plugin from '${project.name.toLowerCase().replace(/\s+/g, '-')}';

function ${pluginName}Component() {
  const audioContextRef = useRef(null);
  const pluginRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [parameters, setParameters] = useState({});

  useEffect(() => {
    // Initialize audio context and plugin
    audioContextRef.current = new AudioContext();
    pluginRef.current = new ${pluginName}Plugin(audioContextRef.current);

    const state = pluginRef.current.getState();
    setParameters(state);

    // Connect to destination
    pluginRef.current.connect(audioContextRef.current.destination);

    return () => {
      // Cleanup
      pluginRef.current?.dispose();
      audioContextRef.current?.close();
    };
  }, []);

  const handleStart = () => {
    audioContextRef.current?.resume();
    setIsPlaying(true);
  };

  const handleStop = () => {
    audioContextRef.current?.suspend();
    setIsPlaying(false);
  };

  const handleParameterChange = (name, value) => {
    pluginRef.current?.setParameter(name, value);
    setParameters((prev) => ({ ...prev, [name]: value }));
  };

  return (
    <div className="plugin-container">
      <h1>${project.name}</h1>

      <div className="transport">
        <button onClick={handleStart} disabled={isPlaying}>
          Start
        </button>
        <button onClick={handleStop} disabled={!isPlaying}>
          Stop
        </button>
      </div>

      <div className="controls">
        {Object.entries(parameters).map(([name, value]) => (
          <div key={name} className="control">
            <label>
              {name}: {value.toFixed(2)}
            </label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.01"
              value={value}
              onChange={(e) =>
                handleParameterChange(name, parseFloat(e.target.value))
              }
            />
          </div>
        ))}
      </div>
    </div>
  );
}

export default ${pluginName}Component;
`;
}

function generateVueExample(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');
  const packageName = project.name.toLowerCase().replace(/\s+/g, '-');

  return `<template>
  <div class="plugin-container">
    <h1>${project.name}</h1>

    <div class="transport">
      <button @click="start" :disabled="isPlaying">Start</button>
      <button @click="stop" :disabled="!isPlaying">Stop</button>
    </div>

    <div class="controls">
      <div v-for="(value, name) in parameters" :key="name" class="control">
        <label>
          {{ name }}: {{ value.toFixed(2) }}
        </label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          :value="value"
          @input="setParameter(name, $event.target.value)"
        />
      </div>
    </div>
  </div>
</template>

<script>
import ${pluginName}Plugin from '${packageName}';

export default {
  name: '${pluginName}Component',
  data() {
    return {
      audioContext: null,
      plugin: null,
      isPlaying: false,
      parameters: {},
    };
  },
  mounted() {
    this.audioContext = new AudioContext();
    this.plugin = new ${pluginName}Plugin(this.audioContext);
    this.parameters = this.plugin.getState();
    this.plugin.connect(this.audioContext.destination);
  },
  beforeUnmount() {
    this.plugin?.dispose();
    this.audioContext?.close();
  },
  methods: {
    start() {
      this.audioContext?.resume();
      this.isPlaying = true;
    },
    stop() {
      this.audioContext?.suspend();
      this.isPlaying = false;
    },
    setParameter(name, value) {
      const numValue = parseFloat(value);
      this.plugin?.setParameter(name, numValue);
      this.parameters[name] = numValue;
    },
  },
};
</script>

<style scoped>
.plugin-container {
  padding: 20px;
}
.transport {
  margin: 20px 0;
}
.controls {
  display: grid;
  gap: 10px;
}
</style>
`;
}

function generateNPMReadme(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');
  const packageName = project.name.toLowerCase().replace(/\s+/g, '-');

  return `# ${project.name}

${project.description}

Generated by [Sound Designer](https://sounddesigner.com)

## Installation

\`\`\`bash
npm install ${packageName}
\`\`\`

## Quick Start

\`\`\`javascript
import ${pluginName}Plugin from '${packageName}';

// Create audio context
const audioContext = new AudioContext();

// Create plugin instance
const plugin = new ${pluginName}Plugin(audioContext);

// Connect to destination
plugin.connect(audioContext.destination);

// Set parameters
plugin.setParameter('gain', 0.8);

// Get current state
const state = plugin.getState();
console.log(state);
\`\`\`

## API Documentation

### Constructor

\`\`\`typescript
new ${pluginName}Plugin(audioContext: AudioContext, options?: ${pluginName}Options)
\`\`\`

Creates a new instance of the plugin.

**Parameters:**
- \`audioContext\`: Web Audio API AudioContext
- \`options\`: Optional configuration

### Methods

#### \`connect(destination: AudioNode | AudioParam): AudioNode | AudioParam\`

Connect plugin output to a destination node or parameter.

#### \`disconnect(): void\`

Disconnect plugin output.

#### \`setParameter(name: string, value: number, time?: number): void\`

Set parameter value with optional automation time.

#### \`getParameter(name: string): number | undefined\`

Get current parameter value.

#### \`getState(): object\`

Get all parameter values as an object.

#### \`setState(state: object): void\`

Set multiple parameters from state object.

#### \`exportPreset(): string\`

Export current state as JSON string.

#### \`importPreset(json: string): void\`

Import state from JSON string.

#### \`dispose(): void\`

Clean up resources and disconnect all nodes.

## Parameters

${project.dspGraph.nodes
  .flatMap((node) =>
    (node.parameters || []).map((param) => {
      const paramName = sanitizeName(\`\${node.label || node.type}_\${param.name}\`);
      return \`- \`\${paramName}\`: \${param.name} (\${param.min ?? 0} - \${param.max ?? 1})\`;
    })
  )
  .join('\\n')}

## Examples

### Vanilla JavaScript

See [examples/basic.html](examples/basic.html)

### React

See [examples/react-example.jsx](examples/react-example.jsx)

### Vue

See [examples/vue-example.vue](examples/vue-example.vue)

## TypeScript Support

This package includes TypeScript definitions.

\`\`\`typescript
import ${pluginName}Plugin, { ${pluginName}Parameters } from '${packageName}';

const plugin = new ${pluginName}Plugin(audioContext);
plugin.setParameter('gain', 0.5);
\`\`\`

## License

MIT Â© ${new Date().getFullYear()} ${project.author || 'Sound Designer'}

## Support

For issues and questions, please visit:
- GitHub Issues: https://github.com/yourusername/${packageName}/issues
- Documentation: https://github.com/yourusername/${packageName}#readme
`;
}

function generateAPIDocs(project: PluginProject): string {
  return `# API Documentation

Full API documentation for ${project.name}.

## Table of Contents

1. [Plugin Class](#plugin-class)
2. [Parameters](#parameters)
3. [Methods](#methods)
4. [Events](#events)
5. [Types](#types)

## Plugin Class

The main plugin class provides audio processing capabilities.

[API documentation would continue here with detailed descriptions]
`;
}

async function generateAdditionalFiles(project: PluginProject, outputDir: string): Promise<void> {
  // .npmignore
  const npmignore = `src/
test/
examples/
docs/
tsconfig.json
rollup.config.js
.eslintrc
*.test.js
*.spec.js
`;
  await fs.writeFile(path.join(outputDir, '.npmignore'), npmignore, 'utf-8');

  // .gitignore
  const gitignore = `node_modules/
dist/
*.log
.DS_Store
`;
  await fs.writeFile(path.join(outputDir, '.gitignore'), gitignore, 'utf-8');

  // LICENSE
  const license = `MIT License

Copyright (c) ${new Date().getFullYear()} ${project.author || 'Sound Designer'}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
`;
  await fs.writeFile(path.join(outputDir, 'LICENSE'), license, 'utf-8');

  // CHANGELOG.md
  const changelog = `# Changelog

## [${project.version}] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial release
- Full Web Audio API implementation
- TypeScript support
- NPM package generation
`;
  await fs.writeFile(path.join(outputDir, 'CHANGELOG.md'), changelog, 'utf-8');
}

// Helper functions
function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9]/g, '_').replace(/^_+|_+$/g, '');
}

function generateNodeCreation(project: PluginProject): string {
  const code: string[] = [];

  project.dspGraph.nodes.forEach((node, index) => {
    const nodeName = sanitizeName(node.label || \`\${node.type}\${index}\`);

    switch (node.type) {
      case 'oscillator':
        code.push(\`    const \${nodeName} = this.context.createOscillator();\`);
        code.push(\`    \${nodeName}.type = 'sine';\`);
        code.push(\`    \${nodeName}.start();\`);
        code.push(\`    this.nodes.set('\${nodeName}', \${nodeName});\`);
        break;

      case 'filter':
        code.push(\`    const \${nodeName} = this.context.createBiquadFilter();\`);
        code.push(\`    \${nodeName}.type = 'lowpass';\`);
        code.push(\`    this.nodes.set('\${nodeName}', \${nodeName});\`);
        code.push(\`    this.parameters.set('\${nodeName}_frequency', \${nodeName}.frequency);\`);
        code.push(\`    this.parameters.set('\${nodeName}_Q', \${nodeName}.Q);\`);
        break;

      case 'gain':
        code.push(\`    const \${nodeName} = this.context.createGain();\`);
        code.push(\`    this.nodes.set('\${nodeName}', \${nodeName});\`);
        code.push(\`    this.parameters.set('\${nodeName}_gain', \${nodeName}.gain);\`);
        break;

      case 'delay':
        code.push(\`    const \${nodeName} = this.context.createDelay(5.0);\`);
        code.push(\`    this.nodes.set('\${nodeName}', \${nodeName});\`);
        code.push(\`    this.parameters.set('\${nodeName}_delayTime', \${nodeName}.delayTime);\`);
        break;
    }
  });

  return code.join('\\n');
}

function generateDSPChainSetup(project: PluginProject): string {
  const connections: string[] = [];
  const nodes = project.dspGraph.nodes.map((n, i) => sanitizeName(n.label || \`\${n.type}\${i}\`));

  if (nodes.length > 0) {
    connections.push(\`    this.input.connect(this.nodes.get('\${nodes[0]}')!);\`);

    for (let i = 0; i < nodes.length - 1; i++) {
      connections.push(\`    this.nodes.get('\${nodes[i]}')!.connect(this.nodes.get('\${nodes[i + 1]}')!);\`);
    }

    connections.push(\`    this.nodes.get('\${nodes[nodes.length - 1]}')!.connect(this.output);\`);
  } else {
    connections.push('    this.input.connect(this.output);');
  }

  return connections.join('\\n');
}
