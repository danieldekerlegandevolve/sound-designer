import { PluginProject, DSPNode } from '@shared/types';

/**
 * Export plugin to Web Audio API JavaScript/TypeScript
 */

export function generateWebAudioPlugin(project: PluginProject): {
  js: string;
  html: string;
  package: string;
} {
  const pluginName = project.name.replace(/\s+/g, '');

  const js = generateWebAudioJS(project);
  const html = generateWebAudioHTML(project);
  const packageJson = generatePackageJSON(project);

  return { js, html, package: packageJson };
}

function generateWebAudioJS(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `/**
 * ${project.name} - Web Audio Plugin
 * Generated by Sound Designer
 * Version: ${project.version}
 */

class ${pluginName}Plugin {
  constructor(audioContext) {
    this.context = audioContext;
    this.input = this.context.createGain();
    this.output = this.context.createGain();

    // Parameters
    this.parameters = {
      ${generateWebAudioParameters(project)}
    };

    // DSP nodes
    ${generateWebAudioNodes(project)}

    // Connect DSP chain
    this.buildDSPChain();
  }

  buildDSPChain() {
    ${generateWebAudioConnections(project)}
  }

  connect(destination) {
    this.output.connect(destination);
    return destination;
  }

  disconnect() {
    this.output.disconnect();
  }

  // Parameter automation
  setParameter(name, value, time = 0) {
    const param = this.parameters[name];
    if (!param) {
      console.warn(\`Parameter \${name} not found\`);
      return;
    }

    if (time === 0) {
      param.value = value;
    } else {
      param.setValueAtTime(param.value, this.context.currentTime);
      param.linearRampToValueAtTime(value, this.context.currentTime + time);
    }
  }

  getParameter(name) {
    return this.parameters[name]?.value;
  }

  // State management
  getState() {
    const state = {};
    for (const [name, param] of Object.entries(this.parameters)) {
      state[name] = param.value;
    }
    return state;
  }

  setState(state) {
    for (const [name, value] of Object.entries(state)) {
      this.setParameter(name, value);
    }
  }

  // Cleanup
  dispose() {
    this.disconnect();
    ${generateWebAudioCleanup(project)}
  }
}

// Export for use
export default ${pluginName}Plugin;

// Browser global
if (typeof window !== 'undefined') {
  window.${pluginName}Plugin = ${pluginName}Plugin;
}
`;
}

function generateWebAudioParameters(project: PluginProject): string {
  const params: string[] = [];

  project.dspGraph.nodes.forEach(node => {
    node.parameters?.forEach(param => {
      const paramName = sanitizeName(`${node.label || node.type}_${param.name}`);
      const min = param.min ?? 0;
      const max = param.max ?? 1;
      const defaultVal = param.default;

      // Create AudioParam wrapper
      params.push(`${paramName}: { value: ${defaultVal}, min: ${min}, max: ${max} }`);
    });
  });

  return params.join(',\n      ');
}

function generateWebAudioNodes(project: PluginProject): string {
  const nodes: string[] = [];

  project.dspGraph.nodes.forEach(node => {
    const nodeName = sanitizeName(node.label || node.type);

    switch (node.type) {
      case 'oscillator':
        nodes.push(`this.${nodeName} = this.context.createOscillator();`);
        nodes.push(`this.${nodeName}.type = '${getOscillatorType(node)}';`);
        nodes.push(`this.${nodeName}.start();`);
        break;

      case 'filter':
        nodes.push(`this.${nodeName} = this.context.createBiquadFilter();`);
        nodes.push(`this.${nodeName}.type = '${getFilterType(node)}';`);
        const freq = node.parameters?.find(p => p.name === 'frequency');
        if (freq) nodes.push(`this.${nodeName}.frequency.value = ${freq.value};`);
        const q = node.parameters?.find(p => p.name === 'Q');
        if (q) nodes.push(`this.${nodeName}.Q.value = ${q.value};`);
        break;

      case 'gain':
        nodes.push(`this.${nodeName} = this.context.createGain();`);
        const gain = node.parameters?.find(p => p.name === 'gain');
        if (gain) nodes.push(`this.${nodeName}.gain.value = ${gain.value};`);
        break;

      case 'delay':
        nodes.push(`this.${nodeName} = this.context.createDelay(5.0);`);
        const delayTime = node.parameters?.find(p => p.name === 'time' || p.name === 'delayTime');
        if (delayTime) nodes.push(`this.${nodeName}.delayTime.value = ${delayTime.value};`);
        break;

      case 'compressor':
        nodes.push(`this.${nodeName} = this.context.createDynamicsCompressor();`);
        const threshold = node.parameters?.find(p => p.name === 'threshold');
        if (threshold) nodes.push(`this.${nodeName}.threshold.value = ${threshold.value};`);
        const ratio = node.parameters?.find(p => p.name === 'ratio');
        if (ratio) nodes.push(`this.${nodeName}.ratio.value = ${ratio.value};`);
        break;

      case 'reverb':
        nodes.push(`this.${nodeName} = this.context.createConvolver();`);
        nodes.push(`// TODO: Load impulse response for reverb`);
        break;

      case 'distortion':
        nodes.push(`this.${nodeName} = this.context.createWaveShaper();`);
        nodes.push(`this.${nodeName}.curve = this.makeDistortionCurve(400);`);
        break;
    }
  });

  // Add distortion curve generator if needed
  if (project.dspGraph.nodes.some(n => n.type === 'distortion')) {
    nodes.push(`
    this.makeDistortionCurve = (amount) => {
      const samples = 44100;
      const curve = new Float32Array(samples);
      const deg = Math.PI / 180;
      for (let i = 0; i < samples; ++i) {
        const x = (i * 2) / samples - 1;
        curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
      }
      return curve;
    };`);
  }

  return nodes.join('\n    ');
}

function generateWebAudioConnections(project: PluginProject): string {
  const connections: string[] = [];

  // Connect input
  connections.push('this.input.connect(this.output);');

  // TODO: Parse actual connections from project.dspGraph.connections
  // For now, create a simple chain
  const nodes = project.dspGraph.nodes.map(n => sanitizeName(n.label || n.type));

  if (nodes.length > 0) {
    connections.push(`this.input.connect(this.${nodes[0]});`);

    for (let i = 0; i < nodes.length - 1; i++) {
      connections.push(`this.${nodes[i]}.connect(this.${nodes[i + 1]});`);
    }

    connections.push(`this.${nodes[nodes.length - 1]}.connect(this.output);`);
  }

  return connections.join('\n    ');
}

function generateWebAudioCleanup(project: PluginProject): string {
  const cleanup: string[] = [];

  project.dspGraph.nodes.forEach(node => {
    const nodeName = sanitizeName(node.label || node.type);

    if (node.type === 'oscillator') {
      cleanup.push(`this.${nodeName}.stop();`);
    }

    cleanup.push(`this.${nodeName}.disconnect();`);
  });

  return cleanup.join('\n    ');
}

function generateWebAudioHTML(project: PluginProject): string {
  const pluginName = project.name.replace(/\s+/g, '');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${project.name}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      margin: 0;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }

    .plugin-container {
      max-width: ${project.settings.width}px;
      margin: 0 auto;
      background: #2a2a2a;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    h1 {
      margin: 0 0 20px 0;
      font-size: 28px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .control label {
      font-size: 14px;
      color: #aaa;
      font-weight: 500;
    }

    .control input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #3a3a3a;
      outline: none;
      -webkit-appearance: none;
    }

    .control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #4a9eff;
      cursor: pointer;
    }

    .control .value {
      font-size: 12px;
      color: #888;
      text-align: right;
    }

    .transport {
      display: flex;
      gap: 10px;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #3a3a3a;
    }

    button {
      padding: 12px 24px;
      background: #4a9eff;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    button:hover {
      background: #3a8eef;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button.stop {
      background: #cc4444;
    }

    button.stop:hover {
      background: #bb3333;
    }
  </style>
</head>
<body>
  <div class="plugin-container">
    <h1>${project.name}</h1>
    <p style="color: #888; margin: 0;">${project.description}</p>

    <div class="controls" id="controls">
      <!-- Controls will be generated by JavaScript -->
    </div>

    <div class="transport">
      <button id="startBtn">Start</button>
      <button id="stopBtn" class="stop">Stop</button>
    </div>
  </div>

  <script type="module">
    import ${pluginName}Plugin from './${pluginName}.js';

    let audioContext;
    let plugin;
    let isPlaying = false;

    // Initialize audio context and plugin
    function init() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      plugin = new ${pluginName}Plugin(audioContext);
      plugin.connect(audioContext.destination);

      // Generate UI controls
      generateControls();
    }

    function generateControls() {
      const container = document.getElementById('controls');
      container.innerHTML = '';

      for (const [name, param] of Object.entries(plugin.parameters)) {
        const control = document.createElement('div');
        control.className = 'control';

        const label = document.createElement('label');
        label.textContent = name.replace(/_/g, ' ');

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = param.min;
        slider.max = param.max;
        slider.value = param.value;
        slider.step = (param.max - param.min) / 100;

        const valueDisplay = document.createElement('div');
        valueDisplay.className = 'value';
        valueDisplay.textContent = param.value.toFixed(2);

        slider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          plugin.setParameter(name, value);
          valueDisplay.textContent = value.toFixed(2);
        });

        control.appendChild(label);
        control.appendChild(slider);
        control.appendChild(valueDisplay);
        container.appendChild(control);
      }
    }

    // Transport controls
    document.getElementById('startBtn').addEventListener('click', () => {
      if (!audioContext) init();
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      isPlaying = true;
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
      if (audioContext && audioContext.state === 'running') {
        audioContext.suspend();
      }
      isPlaying = false;
    });

    // Auto-initialize on user interaction
    document.addEventListener('click', () => {
      if (!audioContext) init();
    }, { once: true });
  </script>
</body>
</html>
`;
}

function generatePackageJSON(project: PluginProject): string {
  const pluginName = project.name.toLowerCase().replace(/\s+/g, '-');

  return JSON.stringify({
    name: pluginName,
    version: project.version,
    description: project.description,
    main: 'index.js',
    type: 'module',
    scripts: {
      start: 'python3 -m http.server 8000',
      build: 'echo "No build step required for Web Audio"',
    },
    keywords: ['audio', 'plugin', 'web-audio', 'sound-designer'],
    author: project.author || 'Sound Designer',
    license: 'MIT',
  }, null, 2);
}

// Helper functions

function getOscillatorType(node: DSPNode): string {
  const typeParam = node.parameters?.find(p => p.name === 'waveform' || p.name === 'type');
  return typeParam?.value || 'sine';
}

function getFilterType(node: DSPNode): string {
  const typeParam = node.parameters?.find(p => p.name === 'type');
  return typeParam?.value || 'lowpass';
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9]/g, '_').replace(/^_+|_+$/g, '');
}
